<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>js笔记</title>
</head>
<body>


<script>
		//最好的做法是把 js标签 放到html文档最后,(/body)标签之前

		//js变量区分大小写

		//函数名,方法名,对象属性名 惯例用---驼峰命名

		//转译符是(\)反斜杠 例如 'I don't kown'---应该写成 'I don\'t kown'
</script>

js对象只是带有属性和方法的 特殊储存数据类型 比数组更大一个级别的储存容器 ---w3c

php要创建一个新对象，使用 new 语句实例化一个类得到

感觉js的对象 就像 php的类  但js的对象只是带有属性和方法的特殊储存数据类型

js 用 new 实例化对象,得到一个对象的实例

js所有事物 字符串、数值、数组、函数...都是某种类型的对象---p18
js变量 就是某种类型的对象

php的变量不能是类, php变量 可以是 new一个类得到的实例化
   <!-- 比如一个变量是数组,那他就是Array类型的对象
			一个变量是布尔值,那他就是Boolean类型的对象 -->
<script>
//声明数组
	var arr = Array(); //---注意:A必须大写 否则不是声明数组
		arr[0]="aa";
		arr[1]="bb";
		arr[2]="cc";

	var arr2 = [];      //这也是声明数组,
		arr2[0]="aa";
		arr2[1]="bb";
		arr2[2]="cc";

	var arr3 = ["a","b","c"]; 这也是声明数组

						//数组的元素可以是对象,数组

//遍历数组 要用数组的array.length属性

//关联数组
	//本质上
	//关联数组中的键,其实就是一个Array类的对象的属性
	//关联数组中的值,其实就是一个Array类的对象的属性值

	var arr3 = [];      
		arr3['name']="aa";
		arr3['sex']="bb";
		arr3['age']="cc";


//对象
		//与数组类似,一个名字表示一组值,对象的每个值都是对象的一个属性

//声明对象
	var obj = Object();   //对比声明数组
		obj.name = "aa";
		obj.sex = "bb";
		obj.age = "cc";

	var obj2 = {};      //对比声明数组[],
		obj2.name ="aa";
		obj2.sex ="bb";
		obj2.age ="cc";

	var obj3 = {name:"aa", age:33, wedding:true };	//属性不用引号,属性值用引号

//数组元素是对象的情况
	var arr4 = [];      
		arr4[0] = obj2;

		alert(arr4[0].name);   //---重点--- 这样取到的值是aa 不能写成arr4[0][0]------重点


// 对象的属性和方法都用点连接
	var Person = Object();
		Person.age;
		Person.walk();

//对象的实例 可以直接使用对象中的属性和方法
		var yan = new Person();
			yan.age;
			yan.walk();		

//从对象 和数组 的对比可以看出,不推荐用关联数组,关联数组其实就是对象,关联数组的元素,就是对象的属性,而对象一般不应该修改属性,而应该使用通用的对象



//加号(+)
		// 两个数值用+号 结果是求和
		// 两个字符串用+号 结果是拼接字符串
		// 一个数值 + 一个字符串 结果是拼接字符串--------------重点


//函数  用 参数 来接收数据 用 return 来返回数据
		// 函数的真正价值,可以把函数的调用结果赋给一个变量
		
		// var fun = 函数名(参数); 注意驼峰法函数名

//作用域
		// 在函数外面 var 就是全局变量
		// 在函数里面 var 就是局部变量




//DOM 是通用API----DOM适用任何标记语言,不仅限于web

	// 把网页文档 转成对象的形式,每一个元素都是一个对象----------重点

	// 节点---好像是从不同3个方面,描述文档的某同一块部分
			//元素节点 
			//文本节点 
			//属性节点 

		//获得元素---三个DOM方法 
					// document对象的方法
						  var abc = document.getElementById("id");       //返回一个对象, id名必须引号
									document.getElementsByTagName(""); 
												//返回一个数组,数组中每个元素都是一个对象,
												//即使只有一个元素 
													document.getElementsByTagName("name")[0]
									document.getElementsByClassame(""); //同上


		//获得,设置属性
					// getAttribute() setAttribute() 不属于document对象 不能通过document调用
					//是(元素节点对象) 的方法
							  abc.getAttribut("属性名");
							  abc.setAttribut("属性名","属性值");


					//非DOM方法 .value .src 不推荐使用,不是所有属性都可以这样写.




// 事件处理函数event handler---(注意:① onclick这些事件,它们都是函数.
								   //② handler英文翻译是句柄,处理者,从这里看handler就是函数)
</script>				
				<!--JS和html混合在一起使用-->
						<a href="http://www.baidu.com" onclick = "showPic(this); return false;"></a>
		
						<!--  onclick = ""
										引号里是函数体,里面放js代码
										引号里的代码,可以有返回值, 返回值返给 onclick事件函数,返回false 不执行链接
										用(;)分号间隔
										this 表示这个<a>元素节点
						 -->
						搜索引擎不理解js,所以跳转链接不要写成 href="#"
												   也不要写成 href="javascript:"伪协议
												   以上不利于搜索引擎抓取
												   
												   应该这样写 href="http://www.baidu.com"										   
<script>
				//JS与html标签分离
						var getid = document.getElementById("aa");//取id元素
						var links = getid.getElementsByTagName("a");//取id元素里的所有a标签
						
						for(var i = 0;i<links.length;i++){//用循环给每个a加onclick事件
							
								links[i].onclick = function(){//------匿名函数
									showPic(this);
									return false;//阻止a跳转
								}
						}



// if(something != null) 不等于空
// if(something) 		 两者等价

window.onload = 函数名;//<body onload="load()">等效
			
				//页面加载完毕后,触发onload事件---直接写函数名后面不用写括号
				//一旦完全加载所有内容（包括图像、脚本文件、CSS 文件等），就执行一段脚本。
				
	//多个函数加载
	window.onload = function(){
		firstFunction();
		secondFunction();
	}
	
	
//addLoadEvent 函数
					//用于页面内触发 onload 事件时执行多个任务。

//首先来梳理一下函数代码
function addLoadEvent(func){ 
//将函数作为参数，此函数就是 onload 触发时需要执行的某个函数
    var oldonload=window.onload; 
    //将原来的 onload 的值赋给临时变量 oldonload。
    if(typeof window.onload!="function"){//注意 先得到typeof window.onload的结果 再去!=比较 
    //判断 onload 的类型是否是 function。如果已经执行window.onload=function(){...} 已经被赋值，那么此时 onload 的类型就是 function
    //否，则说明 onload 还没有被赋值，当前任务 func 就为第一个加入的任务
        window.onload=func(); //作为第一个任务，给 onload 赋值
    }else{ 
    //是，则说明 onload 已被赋值，onload 中先前已有任务加入
        window.onload=function(){
            oldonload();
            func(); //作为后续任务，追加到先前任务oldonload();后面
        }
    }
}

//再来看一个实例。假如需要在 onload 时执行两个任务，分别为 func1 和 func2。
function func1(){
   //...
}
function func2(){
   //...
}

//如果不用 addLoadEvent 函数，那么很有可能会出现下面这样错误的写法。
// do something
window.onload=func1();
// do something
window.onload=func2();

//这样的后果就会是，onload 的值会被最后一次赋值覆盖，func1 将不会执行，只会执行 func2。

//所以正确的写法应该是：
window.onload=function(){
    func1(); // 我们人为判断 func1 是第一个任务
    func2();
}

//以上就是 addLoadEvent 函数流程的最简单形式。出于功能模块封装的考虑，我们将判断 onload 是否被赋值的功能交由模块内部处理
//因此形成了这个函数。最佳的写法就是：
addLoadEvent(func1);
// do something
addLoadEvent(func2);

oldonload 只在 onload 已经被赋值（即至少已经有一个任务）的情况下才有效，它只是起一个传递作用——将原有 onload 的值（即之前的一个或多个任务）放在后续任务之前；


//为什么func和oldonload后面的括号“()”可以写也可以不写啊？那个才是标准。

//在 JavaScript 中一切都是对象，包括函数也是，这是 JavaScript 的内部实现决定的。比如下面的函数定义：
function fn(name){
    alert('Hello '+name);
    return 0;
}

//可以理解为名为 fn 的函数对象变量，fn 即为变量名。事实上，上述函数的定义还可以这样写：
var fn=new Function("name","alert('Hello '+name);return 0;");
//Function([strParamName1,strParamName2,...],strFunctionBody)

//通过这个例子，就可以很容易地看出函数的本来面目。

//因为函数名是就是变量名，因此可以和其他普通变量一样进行作赋值操作：
var sayHello=fn;

//只要给函数对象变量后加上括号，就可以使用函数了：
fn("World"); //alert "Hello World"
sayHello("WANGERN"); //alert "Hello WANGERN"

//很好理解，括号是执行函数的运算符。如果我们要将函数作为变量处理，那么就不需要括号，只有要执行函数时才加上括号，这就是 func 和 oldonload 函数括号时有时无的原因。

//最后，理解一下下面两个赋值操作结果的区别：
var obj1=sayHello; //obj1 为函数对象的引用,引用函数自身,(而不是函数结果)
var obj2=sayHello(); //obj2 加()括号,为立刻调用函数,得到返回值------------------------注意


//------------------------------------------------------------------------------------------------------------------


//childNodes
	document.body.childNodes;
	//childNodes 属性返回节点的子节点集合

//nodeValue
	element.childNodes[0].nodeValue//获取
	element.childNodes[0].nodeValue = value//设置
	
	//如果想返回元素的文本，请记住---元素内的文本是文本节点,必须返回元素的首个子节点--文本节点的值,
	//文本节点是元素的第一个子节点
	
//firstChild和lastChild

//nodeName
		//document.body.nodeName;获得 body 元素的节点名称



//减少查询 DOM次数
		//只要查询DOM中的某些元素,浏览器就会搜索整个DOM树
		//避免重复查询,把查询结果放到变量里
		
		
</script>
<!------------------------------------------------------------------------------------------------------------>
//三元运算符
			<a href="http://www.baidu.com" onclick = "return showPic(this) ? false : true;"></a>
			<!--如果 showPic(this)结果为真,就返回假;如果为假,就返回真-->
			<!--意思就是如果浏览器支持js就阻止跳转链接,如果不支持js就执行a链接跳转-->				
<script>
//三元运算符	
		   var text = whichpic.getAttribute("title") ? whichpic.getAttribute("title") : "";
		   //?问号后面是text的两个可取值,是把三元运算结果赋给text

//------------------------------------------------------------------------------------------------------------

document.write("<p>abc</p>");//把字符串写到文档中,


//Object.innerHTML 
//				设置或读取元素对象里的值,它不像element.childNodes[0].nodeValue分的那么细
//				全部替换掉原有内容--------------注意

推荐用innerHTML 替代 document.write()
								  document.write(); 无法在指定位置添加内容,只能在哪添加,就在哪里引入js
								  Object.innerHTML 给指定对象添加文本  有利于html和js分离
								  
	
	
//createElement方法	创建元素节点
							document.createElement('p');
//createTextNode方法	创建文本节点
							var txt = document.createTextNode('文本');							
//appendChild方法  插入到父元素里的末尾
							parent.appendChild(txt);//向父元素末尾插入文本节点

//parentNode属性  父元素

//insertBefore方法 在元素前插入
				targetElement.parentNode.insertBefore(newElement,targetElement);//在目标元素的父元素里,在目标元素前插入一个新元素
				
//insertAfter() 在元素后插入
				function insertAfter(newElement,targetElement){
					var parent = targetElement.parentNode;
					if(parent.lastChild == targetElement){
						parent.appendChild(newElement);
					}else{
						parent.insertBefore(newElement,targetElement.nextSibling)
					}
				}

//nextSibling


//Ajax
		//XMLHttpRequest对象
							//以往请求由浏览器发出,而js通过XMLHttpRequest对象自己发送和处理
		




</script>
</body>
</html>