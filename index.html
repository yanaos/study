<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>js笔记</title>
</head>
<body>


<script>
		//最好的做法是把 js标签 放到html文档最后,(/body)标签之前

		//js变量区分大小写

		//函数名,方法名,对象属性名 惯例用---驼峰命名

		//转译符是(\)反斜杠 例如 'I don't kown'---应该写成 'I don\'t kown'
</script>

js对象只是带有属性和方法的 特殊储存数据类型 比数组更大一个级别的储存容器 ---w3c

php要创建一个新对象，使用 new 语句实例化一个类得到

感觉js的对象 就像 php的类  但js的对象只是带有属性和方法的特殊储存数据类型

js 用 new 实例化对象,得到一个对象的实例

js所有事物 字符串、数值、数组、函数...都是某种类型的对象---p18
js变量 就是某种类型的对象

php的变量不能是类, php变量 可以是 new一个类得到的实例化
   <!-- 比如一个变量是数组,那他就是Array类型的对象
			一个变量是布尔值,那他就是Boolean类型的对象 -->
<script>
//声明数组
	var arr = Array(); //---注意:A必须大写 否则不是声明数组
		arr[0]="aa";
		arr[1]="bb";
		arr[2]="cc";

	var arr2 = [];      //这也是声明数组,
		arr2[0]="aa";
		arr2[1]="bb";
		arr2[2]="cc";

	var arr3 = ["a","b","c"]; 这也是声明数组

						//数组的元素可以是对象,数组

//遍历数组 要用数组的array.length属性

//关联数组
	//本质上
	//关联数组中的键,其实就是一个Array类的对象的属性
	//关联数组中的值,其实就是一个Array类的对象的属性值

	var arr3 = [];      
		arr3['name']="aa";
		arr3['sex']="bb";
		arr3['age']="cc";


//对象
		//与数组类似,一个名字表示一组值,对象的每个值都是对象的一个属性

//声明对象
	var obj = Object();   //对比声明数组
		obj.name = "aa";
		obj.sex = "bb";
		obj.age = "cc";

	var obj2 = {};      //对比声明数组[],
		obj2.name ="aa";
		obj2.sex ="bb";
		obj2.age ="cc";

	var obj3 = {name:"aa", age:33, wedding:true };	//属性不用引号,属性值用引号

//数组元素是对象的情况
	var arr4 = [];      
		arr4[0] = obj2;

		alert(arr4[0].name);   //---重点--- 这样取到的值是aa 不能写成arr4[0][0]------重点


// 对象的属性和方法都用点连接
	var Person = Object();
		Person.age;
		Person.walk();

//对象的实例 可以直接使用对象中的属性和方法
		var yan = new Person();
			yan.age;
			yan.walk();		

//从对象 和数组 的对比可以看出,不推荐用关联数组,关联数组其实就是对象,关联数组的元素,就是对象的属性,而对象一般不应该修改属性,而应该使用通用的对象



//加号(+)
		// 两个数值用+号 结果是求和
		// 两个字符串用+号 结果是拼接字符串
		// 一个数值 + 一个字符串 结果是拼接字符串--------------重点


//函数  用 参数 来接收数据 用 return 来返回数据
		// 函数的真正价值,可以把函数的调用结果赋给一个变量
		
		// var fun = 函数名(参数); 注意驼峰法函数名

//作用域
		// 在函数外面 var 就是全局变量
		// 在函数里面 var 就是局部变量




//DOM 是通用API----DOM适用任何标记语言,不仅限于web

	// 把网页文档 转成对象的形式,每一个元素都是一个对象----------重点

	// 节点---好像是从不同3个方面,描述文档的某同一块部分
			//元素节点 
			//文本节点 
			//属性节点 

		//获得元素---三个DOM方法 
					// document对象的方法
						  var abc = document.getElementById("id");       //返回一个对象, id名必须引号
									document.getElementsByTagName(""); 
												//返回一个数组,数组中每个元素都是一个对象,
												//即使只有一个元素 
													document.getElementsByTagName("name")[0]
									document.getElementsByClassName(""); //同上


		//获得,设置属性
					// getAttribute() setAttribute() 不属于document对象 不能通过document调用
					//是(元素节点对象) 的方法
							  abc.getAttribut("属性名");
							  //document.getElementsByTagName("input")[0].value是获得或设置input域里面的值 
							  //document.getElementsByTagName("input")[0].getAttribut("value");获得input标签里 value的是 不是域里的值
							  abc.setAttribut("属性名","属性值");


					//非DOM方法 .value .src 不推荐使用,不是所有属性都可以这样写.




// 事件处理函数event handler---(注意:① onclick这些事件,它们都是函数.
								   //② handler英文翻译是句柄,处理者,从这里看handler就是函数)
</script>				
				<!--JS和html混合在一起使用-->
						<a href="http://www.baidu.com" onclick = "showPic(this); return false;"></a>
		
						<!--  onclick = ""
										引号里是函数体,里面放js代码
										引号里的代码,可以有返回值, 返回值返给 onclick事件函数,返回false 不执行链接
										用(;)分号间隔
										this 表示这个<a>元素节点
						 -->
						搜索引擎不理解js,所以跳转链接不要写成 href="#"
												   也不要写成 href="javascript:"伪协议
												   以上不利于搜索引擎抓取
												   
												   应该这样写 href="http://www.baidu.com"										   
<script>
				//JS与html标签分离
						var getid = document.getElementById("aa");//取id元素
						var links = getid.getElementsByTagName("a");//取id元素里的所有a标签
						
						for(var i = 0;i<links.length;i++){//用循环给每个a加onclick事件
							
								links[i].onclick = function(){//------匿名函数
									showPic(this);
									return false;//阻止a跳转
								}
						}



// if(something != null) 不等于空
// if(something) 		 两者等价

window.onload = 函数名;//<body onload="load()">等效
			
				//页面加载完毕后,触发onload事件---直接写函数名后面不用写括号
				//一旦完全加载所有内容（包括图像、脚本文件、CSS 文件等），就执行一段脚本。
				
	//多个函数加载
	window.onload = function(){
		firstFunction();
		secondFunction();
	}
	
	
//addLoadEvent 函数
					//用于页面内触发 onload 事件时执行多个任务。

//首先来梳理一下函数代码
function addLoadEvent(func){ 
//将函数作为参数，此函数就是 onload 触发时需要执行的某个函数
    var oldonload=window.onload; 
    //将原来的 onload 的值赋给临时变量 oldonload。
    if(typeof window.onload!="function"){//注意 先得到typeof window.onload的结果 再去!=比较 
    //判断 onload 的类型是否是 function。如果已经执行window.onload=function(){...} 已经被赋值，那么此时 onload 的类型就是 function
    //否，则说明 onload 还没有被赋值，当前任务 func 就为第一个加入的任务
        window.onload=func(); //作为第一个任务，给 onload 赋值
    }else{ 
    //是，则说明 onload 已被赋值，onload 中先前已有任务加入
        window.onload=function(){
            oldonload();
            func(); //作为后续任务，追加到先前任务oldonload();后面
        }
    }
}

//再来看一个实例。假如需要在 onload 时执行两个任务，分别为 func1 和 func2。
function func1(){
   //...
}
function func2(){
   //...
}

//如果不用 addLoadEvent 函数，那么很有可能会出现下面这样错误的写法。
// do something
window.onload=func1();
// do something
window.onload=func2();

//这样的后果就会是，onload 的值会被最后一次赋值覆盖，func1 将不会执行，只会执行 func2。

//所以正确的写法应该是：
window.onload=function(){
    func1(); // 我们人为判断 func1 是第一个任务
    func2();
}

//以上就是 addLoadEvent 函数流程的最简单形式。出于功能模块封装的考虑，我们将判断 onload 是否被赋值的功能交由模块内部处理
//因此形成了这个函数。最佳的写法就是：
addLoadEvent(func1);
// do something
addLoadEvent(func2);

oldonload 只在 onload 已经被赋值（即至少已经有一个任务）的情况下才有效，它只是起一个传递作用——将原有 onload 的值（即之前的一个或多个任务）放在后续任务之前；


//为什么func和oldonload后面的括号“()”可以写也可以不写啊？那个才是标准。

//在 JavaScript 中一切都是对象，包括函数也是，这是 JavaScript 的内部实现决定的。比如下面的函数定义：
function fn(name){
    alert('Hello '+name);
    return 0;
}

//可以理解为名为 fn 的函数对象变量，fn 即为变量名。事实上，上述函数的定义还可以这样写：
var fn=new Function("name","alert('Hello '+name);return 0;");
//Function([strParamName1,strParamName2,...],strFunctionBody)

//通过这个例子，就可以很容易地看出函数的本来面目。

//因为函数名是就是变量名，因此可以和其他普通变量一样进行作赋值操作：
var sayHello=fn;

//只要给函数对象变量后加上括号，就可以使用函数了：
fn("World"); //alert "Hello World"
sayHello("WANGERN"); //alert "Hello WANGERN"

//很好理解，括号是执行函数的运算符。如果我们要将函数作为变量处理，那么就不需要括号，只有要执行函数时才加上括号，这就是 func 和 oldonload 函数括号时有时无的原因。

//最后，理解一下下面两个赋值操作结果的区别：
var obj1=sayHello; //obj1 为函数对象的引用,引用函数自身,(而不是函数结果)
var obj2=sayHello(); //obj2 加()括号,为立刻调用函数,得到返回值------------------------注意


//------------------------------------------------------------------------------------------------------------------


//childNodes
	document.body.childNodes;
	//childNodes 属性返回节点的子节点集合

//nodeValue
	element.childNodes[0].nodeValue//获取
	element.childNodes[0].nodeValue = value//设置
	
	//如果想返回元素的文本，请记住---元素内的文本是文本节点,必须返回元素的首个子节点--文本节点的值,
	//文本节点是元素的第一个子节点
	element.childNodes[0].childNodes[0].nodeValue;//子节点的子节点
	//不能写成  element.childNodes[0][0].nodeValue;这是错的
//firstChild和lastChild

//nodeName
		//document.body.nodeName;获得 body 元素的节点名称



//减少查询 DOM次数
		//只要查询DOM中的某些元素,浏览器就会搜索整个DOM树
		//避免重复查询,把查询结果放到变量里
		
		
</script>
<!------------------------------------------------------------------------------------------------------------>
//三元运算符
			<a href="http://www.baidu.com" onclick = "return showPic(this) ? false : true;"></a>
			<!--如果 showPic(this)结果为真,就返回假;如果为假,就返回真-->
			<!--意思就是如果浏览器支持js就阻止跳转链接,如果不支持js就执行a链接跳转-->				
<script>
//三元运算符	
		   var text = whichpic.getAttribute("title") ? whichpic.getAttribute("title") : "";
		   //?问号后面是text的两个可取值,是把三元运算结果赋给text

//------------------------------------------------------------------------------------------------------------

document.write("<p>abc</p>");//把字符串写到文档中,


//Object.innerHTML 
//				设置或读取元素对象里的值,它不像element.childNodes[0].nodeValue分的那么细
//				全部替换掉原有内容--------------注意

推荐用innerHTML 替代 document.write()
								  document.write(); 无法在指定位置添加内容,只能在哪添加,就在哪里引入js
								  Object.innerHTML 给指定对象添加文本  有利于html和js分离
								  
	
	
//createElement方法	创建元素节点
							document.createElement('p');
//createTextNode方法	创建文本节点
							var txt = document.createTextNode('文本');							
//appendChild方法  插入到父元素里的末尾
							parent.appendChild(txt);//向父元素末尾插入文本节点

//parentNode属性  父元素

//insertBefore方法 在元素前插入
				targetElement.parentNode.insertBefore(newElement,targetElement);//在目标元素的父元素里,在目标元素前插入一个新元素
				
//insertAfter() 在元素后插入
				function insertAfter(newElement,targetElement){
					var parent = targetElement.parentNode;
					if(parent.lastChild == targetElement){
						parent.appendChild(newElement);
					}else{
						parent.insertBefore(newElement,targetElement.nextSibling)
					}
				}
//parentNode
//childNodes
//firstChild
//lastChild

//nextSibling       下一个同级节点  不一定是元素节点 也可能是文本节点
//previousSibling   前一个同级节点



//style样式 是对象----------注意

//				只能取到内联的style样式值, 
//              外部引用文件 和 head中的style都取不到

				element.style.color;//获取样式
				element.style.color = "#fff";//设置样式---------注意引号,否则被当做变量
				
				element.style.fontFamily;//font-family不能用减号(-)


</script>


潘魏增 陈本峰 玉北 GrayZhang 携程的大漠 林小志
JavaScript:          周爱民、老赵、玉伯、hax, 月影、CatChen, winter, 白露飞 单东林 席新亮 等
DOM 和浏览器兼容性:  winter, 司徒正美、屈超、怿飞 等
HTML 和 CSS:         彪叔、aoao, 怿飞、macji 等
类库框架:            玉伯、JK, cnberg, yiminghe, 元彦 等
前端布道士:          克军、玉伯、怿飞、秦歌、小马 等
不知分到哪一类的:    hujinpu, 李牧、winter, dexteryy, 李超、老鱼、太伯、陈成 等一堆人

肯定漏了 n 多牛人

------------------------------------------------------------------

jq 的 AJAX 除了完成基本的 ajax 操作外，还封装了
jsonp 跨域获取远程数据
提供了 json 的序列化和反序列化
提供了动态加载 js 文件
提供了表单序列化
等等功能，远远超出了 ajax 的一般概念 

------------------------------------------------------------------

每隔一段时间调用一次ajax 用setTimeout,不用setInterval-------------------p310

	setInterval可能会在上一个函数没执行完,就再次调用函数了
	setTimeout 会等待上一个函数调用完成后,再次调用
--------------------------------------------------------------------------------------------------------------------------
//Ajax 
		//XMLHttpRequest对象
							//以往请求由浏览器发出,而js通过XMLHttpRequest对象自己发送和处理
							
<script>
//1  JS 的ajax---用来理解原理 


	//	跨域问题 只能向同一个域中使用相同端口和协议的URL中发送请求；如果URL与启动请求的页面有任何差别，都会引发安全错误。

	//创建 XMLHttpRequest 对象
			var xmlhttp;
			if (window.XMLHttpRequest)
			  {// code for IE7+, Firefox, Chrome, Opera, Safari
			  xmlhttp=new XMLHttpRequest();
			  }
			else
			  {// code for IE6, IE5
			  xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
			  }
	// 将请求发送到服务器，使用 XMLHttpRequest对象的 open()和send()方法

			// 规定请求的类型、URL 以及是否异步处理请求。
			xmlhttp.open("GET","123.php?q="+str,true);

				// open(method,url,async)   调用open()方法并不会真正发送请求，而只是启动一个请求准备发送
			    // method：请求的类型；GET  如果传值,直接写在url后面 ,123.php页里写$q=$_GET["q"];
			    // 
			    // 				       POST 如果需要像HTML表单那样 POST 数据，
				// 				        	请使用 setRequestHeader() 来添加 HTTP 头
				// 				        	然后在send()方法中规定您希望发送的数据：
				// 				        	
				//						    xmlhttp.open("POST","ajax_test.html",true);
				//						    //post方式需要自己设置http的请求头
				//						    xmlhttp.setRequestHeader("Content-type","application/x-www-form-urlencoded");
				//						    						"Content-type","application/x-www-form-urlencoded"这句是在 请求头部 中设置post提交方式
				//						    						通常HTTP协议里，客户端像服务器取得某个网页的时候，必须发送一个HTTP协议的头文件， 
				//						    						
				//						    xmlhttp.send("fname=Henry&lname=Ford");		        				        	
				// 				        	
			    // url：   文件在服务器上的位置 
			    // 		   URL相对于执行代码的当前页面 (使用绝对路径);
			    // 			
			    // async:  true(异步)
			    // 					规定在响应处于 onreadystatechange事件 中的就绪状态时执行的函数：
			    // 					xmlhttp.onreadystatechange=function(){
				// 					  
				// 					  if (xmlhttp.readyState==4 && xmlhttp.status==200){
				// 					   
				// 					    	document.getElementById("myDiv").innerHTML=xmlhttp.responseText;
				//													    //如果来自服务器的响应并非 XML，请使用 responseText属性
				// 					    							   	//XMLHttpRequest 对象的 responseText属性 返回字符串形式的响应
				// 					    }
				// 					}
				// 					xmlhttp.open("GET","ajax_info.txt",true);
				// 					xmlhttp.send();
			    // 							
			    // 							
			    // 		   false(同步)
				// 		    		   	JS会等到服务器响应就绪才继续执行。如果服务器繁忙或缓慢，应用程序会挂起或停止。

				// 						注意：当您使用 async=false 时，请不要编写 onreadystatechange 函数 
				// 													   而是把代码放到 send() 语句后面即可
				// 						
				// 						xmlhttp.open("GET","ajax_info.txt",false);
				// 						xmlhttp.send();
				// 						document.getElementById("myDiv").innerHTML=xmlhttp.responseText;

			//将请求发送到服务器		    
			xmlhttp.send(string);
						// string：仅用于 POST 请求




//2 JQ AJAX
---------------------------------------------------------------------------------
$.ajax({//注意整个信息都在大括号里
	type:	  "get",               //数据发送的方式（post 或者 get）
	url:	  "my.html",           //通过ajax加载my.html文件
	data: 	  {val1:"1",val2:"2"}, //要发送的数据（参数）格式为{'val1':"1","val2":"2"}
	dataType: "json",              //从服务器返回的数据类型json,是json对象 可以直接$.each(),(不需要先字符串转对象,再$.each),
	cache:    false,		 	   //用谷歌可以获取最新数据 而在IE获得是旧数据
								   //这里ajax请求用的get方式，每次请求的URL一模一样，ie读缓存 不读数据库了 
	success:  function(data){

				$.each(data, function( i , v ){//遍历得到的data---他是json对象 
									   键   值
 				});
	},
	error:    function (msg) {     //ajax请求失败后触发的方法
                alert(msg);
    }
});

后台接收数据（参数）

<?php
	val1 = $_GET['val1'];//1
	val2 = $_GET['val2'];//2
?>

-----------------------------------------------------------

jQ ajax---  $.get();
			$.getJSON()
			$.getScript()
			$.post()
			$("#id").load("load.htm"); 方法------前4个通过jq对象调用,但load可以通过任何元素调用

-----------------------------------------------------------

p331 get和post方法提交的区别


-------------------------------------------------        p334

$.post(url_to_send,data,function(result){
	
});
	url_to_send 数据发送到这里
	data 		想要发送的数据 已经串行化
	function 	回调函数
	result 		返回的数据放在一个名为json的对象中--不是必须写result,写data也行

--------------------------------------------------p351

//$.getJSON是 $.ajax({})用 GET 请求获取 JSON 数据 的快捷方式

$.getJSON(url_to_load,{ name: "John", time: "2pm" },function(json){
						//返回的结果是json对象 不是json字符串 不需要字符串转对象的过程
});


------------------------------------------------------------p350
json数据

json对象
双引号才是json对象的标准，单引号是不规范的（虽然在js 中是行的通的）！养成习惯，把json 的名称和字符串值用双引号引,不要用单引号

{
	"books"(根元素):{

			"book"(储存数据的数组):[

				{
					"title":"abc",
					"author":"yanao",
					"year":1983
				},
				{
					"title":"abc",
					"author":"yanao",
					"year":1983
				},
				{
					"title":"abc",
					"author":"yanao",
					"year":1983
				}
			]

	}

}
books.book.length得到返回了多少本书

json对象可以用 点记法(.)
json对象里的数组类似js数组,有同样的属性 如:length


-------------------------------------------------------------------------------------------------------------------

AJAX得到的数据
	json格式字符串转json对象-----------(jq的ajax方法  如果类型选json 或者用getjson()方法 则得到的就是json对象  不用转换)
		var jsonData='{"data1":"Hello,","data2":"world!"}'//json格式字符串
		
			json格式的字符串
					单引号写在{}外，每个属性名和值都必须用双引号(不能是单引号)，否则报错。
	
		JSON.parse()与eval()区别
				
			var value = 1;
			
			var jsonstr = '{"data1":"hello","data2":++value}';
			
			var data1 = eval_r('('+jsonstr+')');console.log(data1);//这时value值为2
			var data2 = JSON.parse(jsonstr);console.log(data2);//报错
			
			从上例就可以明显地看出，eval在解析字符串时，会执行该字符串中的代码（这样的后果是相当恶劣的）
			如上例中，由于用eval解析一个json字符串而造成原先的value的值改变。
	
			《高性能Javascript》一书即指出：警告：关于JSON和eval需要注意的是：
			在代码中使用eval是很危险的，特别是用它执行第三方的JSON数据（其中可能包含恶意代码）时，
			尽可能使用JSON.parse()方法解析字符串本身。该方法可以捕捉JSON中的语法错误，并允许你传入一个函数，用来过滤或转换解析结果。
			
			另外，在一个字符串中如果我们想输出“\”字符，我们必须使用转义字符，所以最终形式是：console.log("\\");
			但是由于JSON.parse解析的是字符串的真实含义，所以每一个"\"又都要使用"\"来进行转义，
			所以最终形式为：console.log(JSON.parse('{"a":"\\\\"}'));
			
		-----------------------------------------------	
		JSON.parse() 不允许用逗号作为结尾------------注意
		JSON.parse("[1, 2, 3, 4, ]");//报错
		-----------------------------------------------
		
			eval()用法
				var jsonStr = '{x : 1, y : 1}';
				var jsonObj = eval('(' +  jsonStr + ')');
		
				如果eval的时候不加括号还会报脚本错误,这是为什么呢？
				
				因为eval中 是一个执行环境，不用括号时{x : 1, y : 1}整个被解释成一个复合语句，{和}在这里就是一个符合语句的分隔符，
				而不是对象直接量的一种语法方式。就像if(true){x=1;}这里的大括号也是充当着复合语句的作用。
				
				接下来x:被解释成标签，像通常用的swicth case语句中的case x：也是一种标签，后面的1被当做一个数字直接量
				
				遇到y被解释成变量标示符，然后再继续解析y后的冒号时就出错了,因为无法识别。
				如果你成eval('{x : 1, y = 1}')就不会报错了，因为y=1是可以被识别的, y=1后eval的结果是返回1。
				
				但是为什么前后加个括号就可以了呢，因为括号在这里表示强制执行，整个'(' +  jsonStr + ')',
				jsonStr也是单引号包围的字符串 形式是''+''+''
				其实被解释成一个表达式运算，而不是一个复合语句，因此jsonStr中的大括号{}被当成对象的语法来识别，当然就可以了。
			
----------------------------------------------------------
AJAX发送的数据
	
	用ajax发送信息,需要把数据串行化为一个对象-----------p332对比331重点

	serialize()序列化表单元素为---字符串，如:a=1&b=2&c=3
	
	serializeArray()序列化表单元素为---JSON数据格式。
											如得到一个SON数据[
																{
																	"name":"a",
																	"value":"1"
																},
																{
																	"name":"c",
																	"value":"3"
																}
															]

	//原始form表单值获取方式(手动)：

		$.ajax({
		   type: "POST",
		   url: "ajax.php",
		   data: "Name=摘取天上星&position=IT技术",
		   success: function(msg){alert(msg);},
		   error: function(error){alert(error);}
		 });

	//JQ serialize()方法取值：

		$.ajax({
		   type: "POST",
		   url:"ajax.php",
		   data:$('#formID').serialize(),// 要提交的表单id
		   success: function(msg) {alert(msg);},
		   error: function(error){alert(error);}
		});

	
	$.param()方法 是serialize()方法的核心，用来对一个数组或对象按照key/value进行序列化。
	
----------------------------------------------------------------------------------------------------------
//$.each()用法  遍历AJAX 返回的json对象

		$.each(json对象,function(){});遍历得到的json对象数据(--只能遍历json对象 如果是json格式字符串 需要转换成对象--)----p362
		
		例如 	
			$.getJSON("a.php?action=getRunners", function(json) {//这里把get要传的值 直接放到url里了
				if (json.runners.length > 0) {
					$('#id').empty();
		
					$.each(json.runners,function() {//注意 -----这里用的是this
						var info = '<li>Name: ' +  this['fname'] + ' ' +  this['lname'] + '. Time: ' +  this['time'] + '</li>';
		
					});
				}
			});


//进行遍历一维数组
		var arr1 = [ "aaa", "bbb", "ccc" ]; 
		$.each(arr1, function(i,val){
		alert(i+"前面是下标后面是值"+val);
		}); 

//遍历二维数组
		var arr2 = [['a', 'aa', 'aaa'], ['b', 'bb', 'bbb'], ['c', 'cc', 'ccc']];
		
		　　$.each(arr2, function(i, item){
		　　$.each(item,function(j,val){
		　　　　alert(j+"前面是下标后面是值"+val);
		　});
		}); 

//循环遍历dom对象
		$.each($("input:hidden"), function(i,val){
			alert(val); //为dom对象
			alert(i); //为下标0 1 2
			alert(val.name);
			alert(val.value);
		});
//结果和上面一样
		$("input:hidden").each(function(i,val){
		alert(i);
		alert(val);
		alert(val.name);
		alert(val.value);
		}); 
---------------------------------------------------------------------------

//php端处理	JSON数据

array_push();向数组尾部插入 变成数组之后再变成json数据

		$a=array("red","green");
		array_push($a,"blue","yellow");


json_encode(array_name); //php把关联数组转为json编码
		<?php
		$arr = array ('a'=>1,'b'=>2,'c'=>3,'d'=>4,'e'=>5);
		echo json_encode($arr);
		?>
		
	//以上例程会输出：
	//{"a":1,"b":2,"c":3,"d":4,"e":5} 
			
			
json_decode($json,true); //接受一个 JSON 格式的字符串并且把它转换为 PHP变量 

		<?php
		$json = '{"a":1,"b":2,"c":3,"d":4,"e":5}';
		var_dump(json_decode($json, true));
		?> 
		//结果为:
		// array(5) {
		// 	["a"] => int(1)
		// 	["b"] => int(2)
		// 	["c"] => int(3)
		// 	["d"] => int(4)
		// 	["e"] => int(5)
		// }


</script>
</body>
</html>